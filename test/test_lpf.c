#include <stdlib.h>
#include <stdio.h>
#include <check.h>
#include "../src/dsp/lpf.h"

lpf *filter = NULL;
float *input = NULL;

void setup_input_data(float **input, size_t input_offset, size_t len) {
	float *result = malloc(sizeof(float) * len);
	ck_assert(result != NULL);
	for (size_t i = 0; i < len; i++) {
		// don't care about the loss of data
		result[i] = (float) (input_offset + i);
	}
	*input = result;
}

void assert_float_array(const float expected[], size_t expected_size, float *actual, size_t actual_size) {
	ck_assert_int_eq(expected_size, actual_size);
	for (size_t i = 0; i < expected_size; i++) {
		ck_assert_int_eq((int32_t ) expected[i] * 10000, (int32_t ) actual[i] * 10000);
	}
}

START_TEST (test_normal) {
	int code = lpf_create(2, 48000, 2400, 2000, 2000, sizeof(float), &filter);
	ck_assert_int_eq(code, 0);

	setup_input_data(&input, 0, 500);
	float *output = NULL;
	size_t output_len = 0;
	lpf_process(input, 500, (void**) &output, &output_len, filter);

	const float expected[] = { 0.000000, 0.001856, 0.007972, 0.020274, 0.038323, 0.055850, 0.058924, 0.029263, -0.045737, -0.158591, -0.269061, -0.300619, -0.150779, 0.285712, 1.088058, 2.285712, 3.849221, 5.699380, 7.730939, 9.841409, 11.954264, 14.029263, 16.058924, 18.055849, 20.038324,
			22.020269, 24.007975, 26.001860, 28.000002, 30.000000, 32.000000, 34.000008, 36.000000, 38.000008, 39.999996, 41.999996, 43.999992, 45.999996, 48.000004, 50.000008, 51.999992, 53.999996, 56.000004, 57.999996, 60.000008, 61.999996, 63.999992, 66.000015, 68.000015, 69.999992, 72.000008,
			73.999992, 75.999992, 78.000000, 80.000015, 82.000015, 83.999992, 86.000023, 87.999992, 90.000015, 92.000008, 93.999985, 96.000000, 97.999992, 100.000008, 102.000000, 104.000000, 105.999977, 108.000008, 110.000008, 111.999992, 113.999985, 116.000000, 117.999992, 120.000000, 121.999992,
			123.999992, 126.000023, 128.000015, 129.999969, 132.000015, 133.999985, 136.000031, 138.000015, 140.000000, 142.000000, 143.999969, 146.000046, 148.000031, 149.999985, 151.999985, 154.000015, 156.000015, 158.000046, 159.999985, 161.999985, 164.000015, 166.000031, 168.000046, 169.999985,
			172.000000, 173.999985, 176.000046, 178.000015, 179.999954, 182.000000, 183.999969, 185.999985, 188.000015, 189.999939, 192.000000, 194.000000, 196.000015, 198.000015, 199.999985, 201.999969, 204.000000, 206.000015, 207.999985, 209.999939, 212.000000, 213.999969, 215.999985, 217.999969,
			219.999969, 222.000000, 224.000015, 226.000031, 227.999969, 230.000015, 231.999985, 234.000000, 235.999985, 238.000000, 240.000015, 242.000000, 244.000000, 246.000000, 248.000046, 250.000046, 251.999969, 253.999985, 256.000031, 258.000000, 259.999969, 262.000031, 264.000031, 265.999969,
			268.000000, 270.000031, 272.000061, 273.999969, 276.000031, 278.000092, 280.000000, 282.000031, 284.000031, 285.999969, 288.000061, 290.000031, 291.999939, 294.000000, 295.999969, 298.000031, 299.999969, 301.999969, 303.999969, 305.999969, 308.000031, 309.999939, 312.000061, 313.999939,
			316.000061, 318.000031, 320.000031, 322.000031, 324.000122, 325.999908, 328.000000, 330.000061, 332.000031, 334.000031, 336.000031, 338.000000, 340.000000, 342.000000, 343.999969, 345.999969, 347.999969, 349.999969, 352.000000, 354.000000, 355.999939, 358.000000, 360.000000, 362.000000,
			363.999969, 365.999969, 367.999939, 370.000092, 372.000031, 373.999908, 376.000031, 378.000031, 380.000061, 382.000061, 384.000000, 386.000000, 387.999969, 389.999969, 391.999939, 393.999969, 396.000061, 398.000000, 400.000031, 401.999939, 404.000000, 405.999969, 408.000000, 410.000061,
			412.000000, 414.000031, 415.999939, 418.000061, 420.000000, 422.000031, 424.000031, 426.000092, 428.000061, 430.000031, 432.000031, 433.999939, 435.999969, 437.999969, 440.000000, 442.000031, 444.000031, 446.000031, 447.999939, 450.000031, 451.999908, 453.999939, 456.000031, 458.000031,
			460.000092, 461.999939, 463.999969, 466.000031, 468.000031, 470.000031 };
	assert_float_array(expected, sizeof(expected) / sizeof(float), output, output_len);

//	free(input);
//	setup_input_data(&input, 500, 500);
//	lpf_process(input, 500, (void**) output, &output_len, filter);
}
END_TEST

void teardown() {
	if (filter != NULL) {
		lpf_destroy(filter);
		filter = NULL;
	}
	if( input != NULL ) {
		free(input);
		input = NULL;
	}
}

void setup() {
	//do nothing
}

Suite* common_suite(void) {
	Suite *s;
	TCase *tc_core;

	s = suite_create("lpf");

	/* Core test case */
	tc_core = tcase_create("Core");

	tcase_add_test(tc_core, test_normal);

	tcase_add_checked_fixture(tc_core, setup, teardown);
	suite_add_tcase(s, tc_core);

	return s;
}

int main(void) {
	int number_failed;
	Suite *s;
	SRunner *sr;

	s = common_suite();
	sr = srunner_create(s);

	srunner_set_fork_status(sr, CK_NOFORK);
	srunner_run_all(sr, CK_NORMAL);
	number_failed = srunner_ntests_failed(sr);
	srunner_free(sr);
	return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
